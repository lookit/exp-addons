<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/components/exp-lookit-dialogue-page/component.js - exp-player</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="https://yui-s.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="https://yui-s.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">
<div id="doc">
    <div id="bd" class="yui3-g">
        <div class="yui3-u-1-5">
            <div id="docs-sidebar" class="sidebar apidocs">
              <h2 style="display:inline;">
              <div>
                <img style="float:right; vertical-align:middle;" src="../assets/css/logo.png" height="70">
                <span>Lookit<br> component<br> docs</span>
              </div>

              </h2>


              <div id="api-list">
                  <div id="api-tabview">
              
                    <div id="api-tabview-panel">
                        <h2 class="off-left">Collections</h2>
                        <ul id="api-modules" class="apis modules">
                            <li class="module-sidebar-components"><a href="../modules/components.html">components</a></li>
                            <li class="module-sidebar-exp-player"><a href="../modules/exp-player.html">exp-player</a></li>
                            <li class="module-sidebar-frames"><a href="../modules/frames.html">frames</a></li>
                            <li class="module-sidebar-mixins"><a href="../modules/mixins.html">mixins</a></li>
                            <li class="module-sidebar-randomizers"><a href="../modules/randomizers.html">randomizers</a></li>
                            <li class="module-sidebar-services"><a href="../modules/services.html">services</a></li>
                        </ul>
                        <h2 class="off-left">All elements</h2>
                              <div id="api-tabview-filter">
                      <input type="search" id="api-filter" placeholder="Type to filter">
                    </div>
                        <ul id="api-classes" class="apis classes">
                            <li><a href="../classes/ExpExitSurvey.html">ExpExitSurvey</a></li>
                            <li><a href="../classes/ExpFrameBase.html">ExpFrameBase</a></li>
                            <li><a href="../classes/ExpLookitDialoguePage.html">ExpLookitDialoguePage</a></li>
                            <li><a href="../classes/ExpLookitExitSurvey.html">ExpLookitExitSurvey</a></li>
                            <li><a href="../classes/ExpLookitGeometryAlternation.html">ExpLookitGeometryAlternation</a></li>
                            <li><a href="../classes/ExpLookitInstructions.html">ExpLookitInstructions</a></li>
                            <li><a href="../classes/ExpLookitMoodQuestionnaire.html">ExpLookitMoodQuestionnaire</a></li>
                            <li><a href="../classes/ExpLookitPreviewExplanation.html">ExpLookitPreviewExplanation</a></li>
                            <li><a href="../classes/ExpLookitStoryPage.html">ExpLookitStoryPage</a></li>
                            <li><a href="../classes/ExpLookitSurvey.html">ExpLookitSurvey</a></li>
                            <li><a href="../classes/ExpLookitText.html">ExpLookitText</a></li>
                            <li><a href="../classes/ExpLookitVideo.html">ExpLookitVideo</a></li>
                            <li><a href="../classes/ExpLookitVideoConsent.html">ExpLookitVideoConsent</a></li>
                            <li><a href="../classes/ExpPlayer.html">ExpPlayer</a></li>
                            <li><a href="../classes/ExpVideoConfig.html">ExpVideoConfig</a></li>
                            <li><a href="../classes/ExpVideoConfigQuality.html">ExpVideoConfigQuality</a></li>
                            <li><a href="../classes/ExpVideoConsent.html">ExpVideoConsent</a></li>
                            <li><a href="../classes/ExpVideoPreview.html">ExpVideoPreview</a></li>
                            <li><a href="../classes/FullScreen.html">FullScreen</a></li>
                            <li><a href="../classes/MediaReload.html">MediaReload</a></li>
                            <li><a href="../classes/permute.html">permute</a></li>
                            <li><a href="../classes/randomParameterSet.html">randomParameterSet</a></li>
                            <li><a href="../classes/videoRecorder.html">videoRecorder</a></li>
                            <li><a href="../classes/VideoRecorderObject.html">VideoRecorderObject</a></li>
                            <li><a href="../classes/VideoRecordMixin.html">VideoRecordMixin</a></li>
                        </ul>
                    </div>
              
                  </div>
              </div>
            </div>
        </div>
        <div class="yui3-u-4-5">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: addon/components/exp-lookit-dialogue-page/component.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import layout from &#x27;./template&#x27;;
import ExpFrameBaseComponent from &#x27;../../components/exp-frame-base/component&#x27;;
import FullScreen from &#x27;../../mixins/full-screen&#x27;;
import VideoRecord from &#x27;../../mixins/video-record&#x27;;

let {
    $
} = Ember;

/**
 * @module exp-player
 * @submodule frames
 */

/**
 * Frame to implement a storybook page with dialogue spoken by characters.
 * First, characters appear and any main narration audio is played.
 * Next, the user can click on the characters to play additional audio
 * associated with each character image, or (for a choice trial) the user clicks
 * one of the images to select it as an answer. Once main narration audio has
 * been played and either a selection has been made (for a choice trial,
 * isChoiceFrame: true) or all
 * required character audio has been played (for a non-choice trial), the user
 * can proceed by pressing &#x27;next&#x27;. (A trial with only main narration audio can
 * also simply auto-proceed when audio is finished.)
 *
 * Recording is optional. If webcam recording is conducted (doRecording: true)
 * then audio does not start until recording does, to ensure the entire trial
 * is recorded.
 *
 * The character images are specified in &#x27;images&#x27;, including an image source,
 * positioning on the screen, any animation at the start of the trial, any
 * associated audio, and whether that audio is required.
 *
 * This frame is displayed fullscreen; if the frame before it is not, that frame
 * needs to include a manual &quot;next&quot; button so that there&#x27;s a user interaction
 * event to trigger fullscreen mode. (Browsers don&#x27;t allow us to switch to FS
 * without a user event.)
 *
 * The examples below show a few expected uses of this frame. In phase-2,
 * two characters are shown; the protagonist is already present, and speaker1
 * flies in from the left. Speaker1 has associated audio (dialogue). After
 * the narrative audio, the user can click on speaker1 to play the audio, and
 * will then be able to proceed.
 *
 * phase-5 is a choice trial, where the user has to click on one of the two
 * images before proceeding.

&#x60;&#x60;&#x60;json
 &quot;frames&quot;:
        &quot;phase-2&quot;: {
            &quot;kind&quot;: &quot;exp-lookit-dialogue-page&quot;,
            &quot;id&quot;: &quot;phase-2&quot;,
            &quot;baseDir&quot;: &quot;https://s3.amazonaws.com/lookitcontents/politeness/&quot;,
            &quot;audioTypes&quot;: [&quot;mp3&quot;, &quot;ogg&quot;],
            &quot;backgroundImage&quot;: &quot;order1_test1_background.png&quot;,
            &quot;doRecording&quot;: false,
            &quot;autoProceed&quot;: false,
            &quot;parentTextBlock&quot;: {
                &quot;title&quot;: &quot;Parents!&quot;,
                &quot;text&quot;: &quot;some instructions&quot;,
                &quot;emph&quot;: true,
                &quot;css&quot;: {
                    &quot;color&quot;: &quot;red&quot;,
                    &quot;font-size&quot;: &quot;12px&quot;
                }
            },
            &quot;images&quot;: [
                {
                    &quot;id&quot;: &quot;protagonist&quot;,
                    &quot;src&quot;: &quot;order1_test1_listener1.png&quot;,
                    &quot;left&quot;: &quot;40&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;
                },
                {
                    &quot;id&quot;: &quot;speaker1&quot;,
                    &quot;text&quot;: &quot;Click to hear what he said!&quot;,
                    &quot;src&quot;: &quot;order1_test1_speaker1.png&quot;,
                    &quot;left&quot;: &quot;20&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;,
                    &quot;animate&quot;: &quot;flyleft&quot;,
                    &quot;requireAudio&quot;: true,
                    &quot;imageAudio&quot;: [
                        {
                            &quot;stub&quot;: &quot;polcon_example_2_2speaker1polite&quot;
                        }
                    ]
                }
            ],
            &quot;audioSources&quot;: [
                {
                    &quot;audioId&quot;: &quot;firstAudio&quot;,
                    &quot;sources&quot;: [
                        {
                            &quot;stub&quot;: &quot;polcon_example_2_1intro&quot;
                        }
                    ]
                }
            ]
        },
        &quot;phase-5&quot;: {
            &quot;kind&quot;: &quot;exp-lookit-dialogue-page&quot;,
            &quot;id&quot;: &quot;phase-5&quot;,
            &quot;baseDir&quot;: &quot;https://s3.amazonaws.com/lookitcontents/politeness/&quot;,
            &quot;audioTypes&quot;: [&quot;mp3&quot;, &quot;ogg&quot;],
            &quot;backgroundImage&quot;: &quot;order1_test1_background.png&quot;,
            &quot;doRecording&quot;: false,
            &quot;autoProceed&quot;: false,
            &quot;isChoiceFrame&quot;: true,
            &quot;parentTextBlock&quot;: {
                &quot;title&quot;: &quot;Parents:&quot;,
                &quot;text&quot;: &quot;click on the character your child selects.&quot;,
                &quot;emph&quot;: true
            },
            &quot;images&quot;: [
                {
                    &quot;id&quot;: &quot;speaker1&quot;,
                    &quot;src&quot;: &quot;order1_test1_speaker1.png&quot;,
                    &quot;left&quot;: &quot;20&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;
                },
                {
                    &quot;id&quot;: &quot;speaker2&quot;,
                    &quot;src&quot;: &quot;order1_test1_speaker2.png&quot;,
                    &quot;left&quot;: &quot;60&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;
                }
            ],
            &quot;audioSources&quot;: [
                {
                    &quot;audioId&quot;: &quot;firstAudio&quot;,
                    &quot;sources&quot;: [
                        {
                            &quot;stub&quot;: &quot;polcon_example_5q1&quot;
                        }
                    ]
                }
            ]
        }
 }

 * &#x60;&#x60;&#x60;
 * @class ExpLookitDialoguePage
 * @extends ExpFrameBase
 * @uses FullScreen
 * @uses VideoRecord
 */

export default ExpFrameBaseComponent.extend(FullScreen, VideoRecord,  {
    type: &#x27;exp-lookit-dialogue-page&#x27;,
    layout: layout,
    displayFullscreen: true, // force fullscreen for all uses of this component
    fullScreenElementId: &#x27;experiment-player&#x27;,
    fsButtonID: &#x27;fsButton&#x27;,

    // Override setting in VideoRecord mixin - only use camera if doing recording
    doUseCamera: Ember.computed.alias(&#x27;doRecording&#x27;),
    // Don&#x27;t need to override startRecordingAutomatically as we override the observer
    // whenPossibleToRecord directly.

    // Track state of experiment
    completedAudio: false, // for main narration audio
    imageAudioPlayed: new Set(),
    currentlyHighlighted: null, // id for image currently selected

    currentAudioIndex: -1, // during initial sequential audio, holds an index into audioSources

    // Can the user click the &#x27;next&#x27; button yet? Require all &#x27;main&#x27; audio to
    // have played. For a choice frame, require that one of the images is
    // selected; for other frames, require that any required image-audio has
    // completed.
    readyToProceed: Ember.computed(&#x27;completedAudio&#x27;, &#x27;imageAudioPlayed&#x27;, &#x27;currentlyHighlighted&#x27;,
        function() {
            var okayToProceed = this.get(&#x27;completedAudio&#x27;);

            if (this.get(&#x27;isChoiceFrame&#x27;) &amp;&amp; !(this.get(&#x27;currentlyHighlighted&#x27;))) {
                okayToProceed = false;
            } else {
                var whichAudioCompleted = this.get(&#x27;imageAudioPlayed&#x27;);
                this.get(&#x27;images&#x27;).forEach(function (im) {
                    if (im.requireAudio &amp;&amp; !(whichAudioCompleted.has(im.id))) {
                        okayToProceed = false;
                    }
                });
            }
            return okayToProceed;
        }),

    // Override to do a bit extra when starting recording
    whenPossibleToRecord: function() {
        var _this = this;
        if (this.get(&#x27;recorder.hasCamAccess&#x27;) &amp;&amp; this.get(&#x27;recorderReady&#x27;)) {
            this.startRecorder().then(() =&gt; {
                _this.set(&#x27;recorderReady&#x27;, false);
                $(&#x27;#waitForVideo&#x27;).hide();
                _this.set(&#x27;currentAudioIndex&#x27;, -1);
                _this.send(&#x27;playNextAudioSegment&#x27;);
            });
        }
    }.observes(&#x27;recorder.hasCamAccess&#x27;, &#x27;recorderReady&#x27;),

    meta: {
        name: &#x27;ExpLookitDialoguePage&#x27;,
        description: &#x27;Frame for a storybook page with dialogue spoken by characters&#x27;,
        parameters: {
            type: &#x27;object&#x27;,
            properties: {
                /**
                 * Phase number (just included as a convenience &amp; sent to server, to make handling collected data simpler)
                 *
                 * @property {Number} nPhase
                 * @default 0
                 */
                nPhase: {
                    type: &#x27;number&#x27;,
                    description: &#x27;Phase number&#x27;,
                    default: 0
                },
                /**
                 * Trial number (just included as a convenience &amp; sent to server, to make handling collected data simpler)
                 *
                 * @property {Number} nTrial
                 * @default 0
                 */
                nTrial: {
                    type: &#x27;number&#x27;,
                    description: &#x27;Trial number&#x27;,
                    default: 0
                },
                /**
                 * URL of background image; will be stretched to width of page
                 *
                 * @property {String} backgroundImage
                 */
                backgroundImage: {
                    type: &#x27;string&#x27;,
                    description: &#x27;URL of background image; will be stretched to width of page&#x27;
                },
                /**
                 * Whether this is a frame where the user needs to click to
                 * select one of the images before proceeding
                 *
                 * @property {Boolean} isChoiceFrame
                 * @default false
                 */
                isChoiceFrame: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether this is a frame where the user needs to click to select one of the images before proceeding&#x27;
                },
                /**
                 * Base directory for where to find stimuli. Any image src
                 * values that are not full paths will be expanded by prefixing
                 * with &#x60;baseDir&#x60; + &#x60;img/&#x60;. Any audio/video src values that give
                 * a value for &#x27;stub&#x27; rather than &#x27;src&#x27; and &#x27;type&#x27; will be
                 * expanded out to
                 * &#x60;baseDir/avtype/[stub].avtype&#x60;, where the potential avtypes
                 * are given by audioTypes and videoTypes.
                 *
                 * Note that baseDir SHOULD include a trailing slash
                 * (e.g., &#x60;http://stimuli.org/myexperiment/&#x60;, not
                 * &#x60;http://stimuli.org/myexperiment&#x60;)
                 *
                 * @property {String} baseDir
                 * @default &#x27;&#x27;
                 */
                baseDir: {
                    type: &#x27;string&#x27;,
                    default: &#x27;&#x27;,
                    description: &#x27;Base directory for all stimuli&#x27;
                },
                /**
                 * List of audio types to expect for any audio specified just
                 * with a string rather than with a list of src/type pairs.
                 * If audioTypes is [&#x27;typeA&#x27;, &#x27;typeB&#x27;] and an audio source
                 * is given as [{&#x27;stub&#x27;: &#x27;intro&#x27;}], the audio source will be
                 * expanded out to
                 *
&#x60;&#x60;&#x60;json
                 [
                        {
                            src: &#x27;baseDir&#x27; + &#x27;typeA/intro.typeA&#x27;,
                            type: &#x27;audio/typeA&#x27;
                        },
                        {
                            src: &#x27;baseDir&#x27; + &#x27;typeB/intro.typeB&#x27;,
                            type: &#x27;audio/typeB&#x27;
                        }
                ]
&#x60;&#x60;&#x60;
                 *
                 * @property {String[]} audioTypes
                 * @default [&#x27;mp3&#x27;, &#x27;ogg&#x27;]
                 */
                audioTypes: {
                    type: &#x27;array&#x27;,
                    default: [&#x27;mp3&#x27;, &#x27;ogg&#x27;],
                    description: &#x27;List of audio types to expect for any audio sources specified as strings rather than lists of src/type pairs&#x27;
                },
                /**
                 * Whether to do webcam recording (will wait for webcam
                 * connection before starting audio if so)
                 *
                 * @property {Boolean} doRecording
                 */
                doRecording: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether to do webcam recording (will wait for webcam connection before starting audio if so&#x27;
                },
                /**
                 * Whether to proceed automatically after audio (and hide
                 * replay/next buttons)
                 *
                 * @property {Boolean} autoProceed
                 */
                autoProceed: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether to proceed automatically after audio (and hide replay/next buttons)&#x27;
                },
                /**
                 * Array of objects describing audio to play at the start of
                 * this frame. Each element describes a separate audio segment.
                 *
                 * @property {Object[]} audioSources
                 *   @param {String} audioId unique string identifying this
                 *      audio segment
                 *   @param {Object[]} sources Array of {src: &#x27;url&#x27;, type:
                 *      &#x27;MIMEtype&#x27;} objects with audio sources for this segment.
                 *
                 * Can also give a single element {stub: &#x27;filename&#x27;}, which will
                 * be expanded out to the appropriate array based on &#x60;baseDir&#x60;
                 * and &#x60;audioTypes&#x60; values; see &#x60;audioTypes&#x60;.
                 *
                 *   @param {Object[]} highlights Array of {&#x27;range&#x27;: [startT,
                 *      endT], &#x27;image&#x27;: &#x27;imageId&#x27;} objects, where the imageId
                 *      values correspond to the ids given in images
                 */
                audioSources: {
                    type: &#x27;array&#x27;,
                    description: &#x27;List of objects specifying audio src and type for audio played during test trial&#x27;,
                    default: [],
                    items: {
                        type: &#x27;object&#x27;,
                        properties: {
                            &#x27;audioId&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;sources&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;src&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;type&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;stub&#x27;: {
                                            type: &#x27;string&#x27;
                                        }
                                    }
                                }
                            },
                            &#x27;highlights&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;range&#x27;: {
                                            type: &#x27;array&#x27;,
                                            items: {
                                                type: &#x27;number&#x27;
                                            }
                                        },
                                        &#x27;image&#x27;: {
                                            &#x27;type&#x27;: &#x27;string&#x27;
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                /**
                 * Text block to display to parent. (Each field is optional)
                 *
                 * @property {Object} parentTextBlock
                 *   @param {String} title title to display
                 *   @param {String} text paragraph of text
                 *   @param {Boolean} emph whether to bold this paragraph
                 *   @param {Object} css object specifying any css properties
                 *      to apply to this section, and their values - e.g.
                 *      {&#x27;color&#x27;: &#x27;red&#x27;, &#x27;font-size&#x27;: &#x27;12px&#x27;}.
                 */
                parentTextBlock: {
                    type: &#x27;object&#x27;,
                    properties: {
                        title: {
                            type: &#x27;string&#x27;
                        },
                        text: {
                            type: &#x27;string&#x27;
                        },
                        emph: {
                            type: &#x27;boolean&#x27;
                        },
                        css: {
                            type: &#x27;object&#x27;,
                            default: {}
                        }
                    },
                    default: []
                },
                /**
                 * Array of images to display and information about their placement
                 *
                 * @property {Object[]} images
                 *   @param {String} id unique ID for this image. This will be used to refer to the choice made by the user, if any.
                 *   @param {String} src URL of image source (can be full URL, or stub to append to baseDir; see &#x60;baseDir&#x60;)
                 *   @param {String} left distance from left of story area to image center, as percentage of story area width
                 *   @param {String} height image height, as percentage of story area height
                 *   @param {String} bottom bottom margin, as percentage of story area height
                 *   @param {String} animate animation to use at start of trial on this image, if any. If not provided, image is shown throughout trial. Options are &#x27;fadein&#x27;, &#x27;fadeout&#x27;, &#x27;flyleft&#x27; (fly from left), and &#x27;flyright&#x27;.
                 *   @param {String} text text to display above image, e.g. &#x27;Click to hear what he said!&#x27; If omitted, no text is shown.
                 *   @param {Object[]} imageAudio sources Array of {src: &#x27;url&#x27;,
                 * type: &#x27;MIMEtype&#x27;} objects with audio sources for audio to play when this image is clicked, if any. (Omit to not associate audio with this image.)
                 *
                 * Can also give a single element {stub: &#x27;filename&#x27;}, which will
                 * be expanded out to the appropriate array based on &#x60;baseDir&#x60;
                 * and &#x60;audioTypes&#x60; values; see &#x60;audioTypes&#x60;.
                 *
                 *   @param {Boolean} requireAudio whether to require the user to click this image and complete the audio associated before proceeding to the next trial. (Incompatible with autoProceed.)
                 */
                images: {
                    type: &#x27;array&#x27;,
                    items: {
                        type: &#x27;object&#x27;,
                        properties: {
                            &#x27;id&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;src&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;left&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;height&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;bottom&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;animate&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;text&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;imageAudio&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;src&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;type&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;stub&#x27;: {
                                            type: &#x27;string&#x27;
                                        }
                                    }
                                }
                            },
                            &#x27;requireAudio&#x27;: {
                                type: &#x27;boolean&#x27;
                            }
                        }
                    }
                }
            }
        },
        data: {
            /**
             * Parameters captured and sent to the server
             *
             * @method serializeContent
             * @param {String} videoID The ID of any video recorded during this frame
             * @param {List} videoList a list of webcam video IDs in case there are &gt;1
             * @param {Object} eventTimings
             * @param {String} currentlyHighlighted which image is selected at
             *   the end of the trial, or null if none is. This indicates the
             *   final selected choice for a choice trial.
             * @return {Object} The payload sent to the server
             */
            type: &#x27;object&#x27;,
            properties: {
                videoId: {
                    type: &#x27;string&#x27;
                },
                currentlyHighlighted: {
                    type: &#x27;string&#x27;
                },
                nTrial: {
                    type: &#x27;number&#x27;
                },
                nPhase: {
                    type: &#x27;number&#x27;
                },
                videoList: {
                    type: &#x27;list&#x27;
                }
            }
        }
    },

    // Move an image up and down until the isSpeaking class is removed.
    // Yes, this could much more naturally be done by using a CSS animation property
    // on isSpeaking, but despite animations getting applied properly to the element,
    // I haven&#x27;t been able to get that working - because of the possibility of ember-
    // specific problems here, I&#x27;m going with something that *works* even if it&#x27;s less
    // elegent.
    wiggle(imageId) {
        var _this = this;
        if ($(&#x27;#&#x27; + imageId).hasClass(&#x27;isSpeaking&#x27;)) {
            $(&#x27;#&#x27; + imageId).animate({&#x27;margin-bottom&#x27;: &#x27;.3%&#x27;}, 250, function() {
                $(&#x27;#&#x27; + imageId).animate({&#x27;margin-bottom&#x27;: &#x27;0%&#x27;}, 250, function() {
                    _this.wiggle(imageId);
                });
            });
        }
    },

    actions: {

        clickSpeaker(imageId) {
            // On a choice frame, highlight this choice
            if (this.get(&#x27;isChoiceFrame&#x27;)) {

                /**
                 * When one of the images is clicked during a choice frame
                 *
                 * @event clickSpeaker
                 * @param {String} imageId
                 */
                this.send(&#x27;setTimeEvent&#x27;, &#x27;clickSpeaker&#x27;, {
                    imageId: imageId
                });

                $(&#x27;.story-image-positioner&#x27;).removeClass(&#x27;highlight&#x27;);
                $(&#x27;#&#x27; + imageId).addClass(&#x27;highlight&#x27;);
                this.set(&#x27;currentlyHighlighted&#x27;, imageId);
                this.notifyPropertyChange(&#x27;readyToProceed&#x27;);

            // In general, play audio associated with this image
            } else {
                // Only allow playing image audio once main narration finishes
                if (this.get(&#x27;completedAudio&#x27;)) {
                    // pause any current audio, and set times to 0
                    $(&#x27;.story-image-positioner&#x27;).removeClass(&#x27;isSpeaking&#x27;);
                    $(&#x27;audio&#x27;).each(function() {
                        this.pause();
                        this.currentTime = 0;
                    });
                    // play this image&#x27;s associated audio
                    $(&#x27;#&#x27; + imageId + &#x27; audio&#x27;)[0].play();
                    // animate the image while audio is playing
                    $(&#x27;#&#x27; + imageId).addClass(&#x27;isSpeaking&#x27;);
                    this.wiggle(imageId);

                    /**
                     * When image audio is started
                     *
                     * @event startSpeakerAudio
                     * @param {String} imageId
                     */
                    this.send(&#x27;setTimeEvent&#x27;, &#x27;startSpeakerAudio&#x27;, {
                        imageId: imageId
                    });
                }
            }
        },

        endSpeakerAudio(imageId) {
            $(&#x27;#&#x27; + imageId).removeClass(&#x27;isSpeaking&#x27;);
        },

        markAudioPlayed(imageId) {

            /**
             * When image audio is played (recorded even if not completed)
             *
             * @event playSpeakerAudio
             * @param {String} imageId
             */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;playSpeakerAudio&#x27;, {
                imageId: imageId
            });

            this.imageAudioPlayed.add(imageId);
            this.notifyPropertyChange(&#x27;readyToProceed&#x27;);
        },

        replay() {
            // pause any current audio, and set times to 0
            $(&#x27;.story-image-positioner&#x27;).removeClass(&#x27;isSpeaking&#x27;);
            $(&#x27;audio&#x27;).each(function() {
                this.pause();
                this.currentTime = 0;
            });
            // reset to index -1 as at start of study
            this.set(&#x27;currentAudioIndex&#x27;, -1);
            // restart audio
            this.send(&#x27;playNextAudioSegment&#x27;);
        },

        finish() {
            var _this = this;
            $(&#x27;.story-image-positioner&#x27;).removeClass(&#x27;isSpeaking&#x27;);
            this.stopRecorder().then(() =&gt; {
                _this.set(&#x27;stoppedRecording&#x27;, true);
                _this.send(&#x27;next&#x27;);
            }, () =&gt; {
                _this.send(&#x27;next&#x27;);
            });
        },

        playNextAudioSegment() {
            this.set(&#x27;currentAudioIndex&#x27;, this.get(&#x27;currentAudioIndex&#x27;) + 1);
            if (this.currentAudioIndex &lt; this.get(&#x27;audioSources&#x27;).length) {
                $(&#x27;#&#x27; + this.get(&#x27;audioSources&#x27;)[this.currentAudioIndex].audioId)[0].play();
            } else {
                if (this.get(&#x27;autoProceed&#x27;)) {
                    this.send(&#x27;finish&#x27;);
                } else {
                    /**
                     * When narration audio is completed
                     *
                     * @event completeMainAudio
                     */
                    this.send(&#x27;setTimeEvent&#x27;, &#x27;completeMainAudio&#x27;);
                    this.set(&#x27;completedAudio&#x27;, true);
                    this.notifyPropertyChange(&#x27;readyToProceed&#x27;);
                }
            }
        }

    },

    // Utility to expand stubs into either full URLs (for images) or
    // array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects (for audio).
    expandAsset(asset, type) {
        var fullAsset = asset;
        var _this = this;

        if (type === &#x27;image&#x27; &amp;&amp; typeof asset === &#x27;string&#x27; &amp;&amp; !(asset.includes(&#x27;://&#x27;))) {
            // Image: replace stub with full URL if needed
            fullAsset = this.get(&#x27;baseDir&#x27;) + &#x27;img/&#x27; + asset;
        } else if (type === &#x27;audio&#x27;) {
            // Audio: replace any source objects that have a
            // &#x27;stub&#x27; attribute with the appropriate expanded source
            // objects
            fullAsset = [];
            var types = this.get(&#x27;audioTypes&#x27;);
            asset.forEach(function(srcObj) {
                if (srcObj.hasOwnProperty(&#x27;stub&#x27;)) {
                    for (var iType = 0; iType &lt; types.length; iType++) {
                        fullAsset.push({
                            src: _this.get(&#x27;baseDir&#x27;) + types[iType] + &#x27;/&#x27; + srcObj.stub + &#x27;.&#x27; + types[iType],
                            type: type + &#x27;/&#x27; + types[iType]
                        });
                    }
                } else {
                    fullAsset.push(srcObj);
                }
            });
        }
        return fullAsset;
    },

    didInsertElement() {

        // Make &#x27;Enter&#x27; == next button
        $(document).on(&#x27;keyup.nexter&#x27;, (e) =&gt; {
            if (this.get(&#x27;readyToProceed&#x27;)) {
                if (e.which === 13) { // enter/return
                    this.send(&#x27;finish&#x27;);
                }
            }
        });

        // Expand any image src stubs &amp; imageAudio stubs
        var _this = this;
        var images = this.get(&#x27;images&#x27;);
        images.forEach(function(im) {
            Ember.set(im, &#x27;src_parsed&#x27;, _this.expandAsset(im.src, &#x27;image&#x27;));
            if (im.hasOwnProperty(&#x27;imageAudio&#x27;)) {
                Ember.set(im, &#x27;imageAudio_parsed&#x27;, _this.expandAsset(im.imageAudio, &#x27;audio&#x27;));
            }
        });
        this.set(&#x27;backgroundImage_parsed&#x27;, _this.expandAsset(this.backgroundImage, &#x27;image&#x27;));

        // Expand any audio src stubs
        var audioSources = this.get(&#x27;audioSources&#x27;);
        audioSources.forEach(function(aud) {
            Ember.set(aud, &#x27;sources_parsed&#x27;, _this.expandAsset(aud.sources, &#x27;audio&#x27;));
        });

        this.set(&#x27;imageAudioPlayed&#x27;, new Set()); // Otherwise persists across frames
        this.set(&#x27;images&#x27;, images);
        this.set(&#x27;audioSources&#x27;, audioSources);

        var parentTextBlock = this.get(&#x27;parentTextBlock&#x27;) || {};
        var css = parentTextBlock.css || {};
        $(&#x27;#parenttext&#x27;).css(css);

        this.send(&#x27;showFullscreen&#x27;);
        $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, true);

        // Any animations as images are displayed at start of this phase
        $(&#x27;.story-image-positioner&#x27;).hide();
        this.get(&#x27;images&#x27;).forEach(function (im) {
            if (im.animate === &#x27;fadein&#x27;) {
                $(&#x27;#&#x27; + im.id).fadeIn(1000);
            } if (im.animate === &#x27;fadeout&#x27;) {
                $(&#x27;#&#x27; + im.id).show();
                $(&#x27;#&#x27; + im.id).fadeOut(1000);
            }else if (im.animate === &#x27;flyleft&#x27;) {
                $(&#x27;#&#x27; + im.id).show();
                $(&#x27;#&#x27; + im.id).css(&#x27;left&#x27;, &#x27;-20%&#x27;);
                $(&#x27;#&#x27; + im.id).animate({
                    left: im.left + &#x27;%&#x27;
                }, 1500);
            } else if (im.animate === &#x27;flyright&#x27;) {
                $(&#x27;#&#x27; + im.id).show();
                $(&#x27;#&#x27; + im.id).css(&#x27;left&#x27;, &#x27;100%&#x27;);
                $(&#x27;#&#x27; + im.id).animate({
                    left: im.left + &#x27;%&#x27;
                }, 1500);
            }else {
                $(&#x27;#&#x27; + im.id).show();
            }
        });

        // If not waiting for recording to start, just go ahead with audio now
        if (!this.get(&#x27;doUseCamera&#x27;)) {
            this.send(&#x27;playNextAudioSegment&#x27;);
        }

        this._super(...arguments);

    },

    willDestroyElement() {
        $(document).off(&#x27;keyup.nexter&#x27;);
        this._super(...arguments);
    }

});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
