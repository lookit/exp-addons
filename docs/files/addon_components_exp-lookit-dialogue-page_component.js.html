<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/components/exp-lookit-dialogue-page/component.js - exp-player</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="exp-player" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ExpExitSurvey.html">ExpExitSurvey</a></li>
                                <li><a href="../classes/ExpExitSurveyPilot.html">ExpExitSurveyPilot</a></li>
                                <li><a href="../classes/ExpFrameBase.html">ExpFrameBase</a></li>
                                <li><a href="../classes/ExpFrameBaseUnsafe.html">ExpFrameBaseUnsafe</a></li>
                                <li><a href="../classes/ExpLookitDialoguePage.html">ExpLookitDialoguePage</a></li>
                                <li><a href="../classes/ExpLookitExitSurvey.html">ExpLookitExitSurvey</a></li>
                                <li><a href="../classes/ExpLookitGeometryAlternation.html">ExpLookitGeometryAlternation</a></li>
                                <li><a href="../classes/ExpLookitInstructions.html">ExpLookitInstructions</a></li>
                                <li><a href="../classes/ExpLookitMoodQuestionnaire.html">ExpLookitMoodQuestionnaire</a></li>
                                <li><a href="../classes/ExpLookitPreferentialLooking.html">ExpLookitPreferentialLooking</a></li>
                                <li><a href="../classes/ExpLookitPreviewExplanation.html">ExpLookitPreviewExplanation</a></li>
                                <li><a href="../classes/ExpLookitStoryPage.html">ExpLookitStoryPage</a></li>
                                <li><a href="../classes/ExpLookitText.html">ExpLookitText</a></li>
                                <li><a href="../classes/ExpMoodQuestionnaire.html">ExpMoodQuestionnaire</a></li>
                                <li><a href="../classes/ExpPhysicsIntro.html">ExpPhysicsIntro</a></li>
                                <li><a href="../classes/ExpPhysicsPreVideo.html">ExpPhysicsPreVideo</a></li>
                                <li><a href="../classes/ExpPhysicsPreviewExplanation.html">ExpPhysicsPreviewExplanation</a></li>
                                <li><a href="../classes/ExpPlayer.html">ExpPlayer</a></li>
                                <li><a href="../classes/ExpVideoConfig.html">ExpVideoConfig</a></li>
                                <li><a href="../classes/ExpVideoConfigQuality.html">ExpVideoConfigQuality</a></li>
                                <li><a href="../classes/ExpVideoConsent.html">ExpVideoConsent</a></li>
                                <li><a href="../classes/ExpVideoPhysics.html">ExpVideoPhysics</a></li>
                                <li><a href="../classes/ExpVideoPreview.html">ExpVideoPreview</a></li>
                                <li><a href="../classes/FullScreen.html">FullScreen</a></li>
                                <li><a href="../classes/geometry.html">geometry</a></li>
                                <li><a href="../classes/MediaReload.html">MediaReload</a></li>
                                <li><a href="../classes/randomParameterSet.html">randomParameterSet</a></li>
                                <li><a href="../classes/videoRecorder.html">videoRecorder</a></li>
                                <li><a href="../classes/VideoRecorderObject.html">VideoRecorderObject</a></li>
                                <li><a href="../classes/VideoRecordMixin.html">VideoRecordMixin</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/components.html">components</a></li>
                                <li><a href="../modules/exp-player.html">exp-player</a></li>
                                <li><a href="../modules/frames.html">frames</a></li>
                                <li><a href="../modules/mixins.html">mixins</a></li>
                                <li><a href="../modules/randomizers.html">randomizers</a></li>
                                <li><a href="../modules/services.html">services</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: addon/components/exp-lookit-dialogue-page/component.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import layout from &#x27;./template&#x27;;
import ExpFrameBaseUnsafeComponent from &#x27;../../components/exp-frame-base-unsafe/component&#x27;;
import FullScreen from &#x27;../../mixins/full-screen&#x27;;
import VideoRecord from &#x27;../../mixins/video-record&#x27;;

let {
    $
} = Ember;

/**
 * @module exp-player
 * @submodule frames
 */

/**
 * Frame to implement a storybook page with dialogue spoken by characters.
 * First, characters appear and any main narration audio is played.
 * Next, the user can click on the characters to play additional audio
 * associated with each character image, or (for a choice trial) the user clicks
 * one of the images to select it as an answer. Once main narration audio has
 * been played and either a selection has been made (for a choice trial,
 * isChoiceFrame: true) or all
 * required character audio has been played (for a non-choice trial), the user
 * can proceed by pressing &#x27;next&#x27;. (A trial with only main narration audio can
 * also simply auto-proceed when audio is finished.)
 *
 * Recording is optional. If webcam recording is conducted (doRecording: true)
 * then audio does not start until recording does, to ensure the entire trial
 * is recorded.
 *
 * The character images are specified in &#x27;images&#x27;, including an image source,
 * positioning on the screen, any animation at the start of the trial, any
 * associated audio, and whether that audio is required.
 *
 * This frame extends ExpFrameBaseUnsafe because it is displayed fullscreen
 * and expected to be repeated.
 *
 * The examples below show a few expected uses of this frame. In phase-2,
 * two characters are shown; the protagonist is already present, and speaker1
 * flies in from the left. Speaker1 has associated audio (dialogue). After
 * the narrative audio, the user can click on speaker1 to play the audio, and
 * will then be able to proceed.
 *
 * phase-5 is a choice trial, where the user has to click on one of the two
 * images before proceeding.

&#x60;&#x60;&#x60;json
 &quot;frames&quot;:
        &quot;phase-2&quot;: {
            &quot;kind&quot;: &quot;exp-lookit-dialogue-page&quot;,
            &quot;id&quot;: &quot;phase-2&quot;,
            &quot;baseDir&quot;: &quot;https://s3.amazonaws.com/lookitcontents/politeness/&quot;,
            &quot;audioTypes&quot;: [&quot;mp3&quot;, &quot;ogg&quot;],
            &quot;backgroundImage&quot;: &quot;order1_test1_background.png&quot;,
            &quot;doRecording&quot;: false,
            &quot;autoProceed&quot;: false,
            &quot;parentTextBlock&quot;: {
                &quot;title&quot;: &quot;Parents!&quot;,
                &quot;text&quot;: &quot;some instructions&quot;,
                &quot;emph&quot;: true
            },
            &quot;images&quot;: [
                {
                    &quot;id&quot;: &quot;protagonist&quot;,
                    &quot;src&quot;: &quot;order1_test1_listener1.png&quot;,
                    &quot;left&quot;: &quot;40&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;
                },
                {
                    &quot;id&quot;: &quot;speaker1&quot;,
                    &quot;text&quot;: &quot;Click to hear what he said!&quot;,
                    &quot;src&quot;: &quot;order1_test1_speaker1.png&quot;,
                    &quot;left&quot;: &quot;20&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;,
                    &quot;animate&quot;: &quot;flyleft&quot;,
                    &quot;requireAudio&quot;: true,
                    &quot;imageAudio&quot;: [
                        {
                            &quot;stub&quot;: &quot;polcon_example_2_2speaker1polite&quot;
                        }
                    ]
                }
            ],
            &quot;audioSources&quot;: [
                {
                    &quot;audioId&quot;: &quot;firstAudio&quot;,
                    &quot;sources&quot;: [
                        {
                            &quot;stub&quot;: &quot;polcon_example_2_1intro&quot;
                        }
                    ]
                }
            ]
        },
        &quot;phase-5&quot;: {
            &quot;kind&quot;: &quot;exp-lookit-dialogue-page&quot;,
            &quot;id&quot;: &quot;phase-5&quot;,
            &quot;baseDir&quot;: &quot;https://s3.amazonaws.com/lookitcontents/politeness/&quot;,
            &quot;audioTypes&quot;: [&quot;mp3&quot;, &quot;ogg&quot;],
            &quot;backgroundImage&quot;: &quot;order1_test1_background.png&quot;,
            &quot;doRecording&quot;: false,
            &quot;autoProceed&quot;: false,
            &quot;isChoiceFrame&quot;: true,
            &quot;parentTextBlock&quot;: {
                &quot;title&quot;: &quot;Parents:&quot;,
                &quot;text&quot;: &quot;click on the character your child selects.&quot;,
                &quot;emph&quot;: true
            },
            &quot;images&quot;: [
                {
                    &quot;id&quot;: &quot;speaker1&quot;,
                    &quot;src&quot;: &quot;order1_test1_speaker1.png&quot;,
                    &quot;left&quot;: &quot;20&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;
                },
                {
                    &quot;id&quot;: &quot;speaker2&quot;,
                    &quot;src&quot;: &quot;order1_test1_speaker2.png&quot;,
                    &quot;left&quot;: &quot;60&quot;,
                    &quot;bottom&quot;: &quot;2&quot;,
                    &quot;height&quot;: &quot;60&quot;
                }
            ],
            &quot;audioSources&quot;: [
                {
                    &quot;audioId&quot;: &quot;firstAudio&quot;,
                    &quot;sources&quot;: [
                        {
                            &quot;stub&quot;: &quot;polcon_example_5q1&quot;
                        }
                    ]
                }
            ]
        }
 }

 * &#x60;&#x60;&#x60;
 * @class ExpLookitDialoguePage
 * @extends ExpFrameBaseUnsafe
 * @uses FullScreen
 * @uses VideoRecord
 */

export default ExpFrameBaseUnsafeComponent.extend(FullScreen, VideoRecord,  {
    // In the Lookit use case, the frame BEFORE the one that goes fullscreen
    // must use &quot;unsafe&quot; saves (in order for the fullscreen event to register as
    // being user-initiated and not from a promise handler) #LEI-369.
    // exp-alternation frames are expected to be repeated, so they need to be
    // unsafe.
    type: &#x27;exp-lookit-dialogue-page&#x27;,
    layout: layout,
    displayFullscreen: true, // force fullscreen for all uses of this component
    fullScreenElementId: &#x27;experiment-player&#x27;,
    fsButtonID: &#x27;fsButton&#x27;,
    videoRecorder: Ember.inject.service(),
    recorder: null,
    hasCamAccess: Ember.computed.alias(&#x27;recorder.hasCamAccess&#x27;),
    videoUploadConnected: Ember.computed.alias(&#x27;recorder.connected&#x27;),

    // Track state of experiment
    completedAudio: false, // for main narration audio
    imageAudioCompleted: new Set(),
    currentlyHighlighted: null, // id for image currently selected

    currentAudioIndex: -1, // during initial sequential audio, holds an index into audioSources

    // Can the user click the &#x27;next&#x27; button yet? Require all &#x27;main&#x27; audio to
    // have played. For a choice frame, require that one of the images is
    // selected; for other frames, require that any required image-audio has
    // completed.
    readyToProceed: Ember.computed(&#x27;completedAudio&#x27;, &#x27;imageAudioCompleted&#x27;, &#x27;currentlyHighlighted&#x27;,
        function() {
            var okayToProceed = this.get(&#x27;completedAudio&#x27;);

            if (this.get(&#x27;isChoiceFrame&#x27;) &amp;&amp; !(this.get(&#x27;currentlyHighlighted&#x27;))) {
                okayToProceed = false;
            } else {
                var whichAudioCompleted = this.get(&#x27;imageAudioCompleted&#x27;);
                this.get(&#x27;images&#x27;).forEach(function (im) {
                    if (im.requireAudio &amp;&amp; !(whichAudioCompleted.has(im.id))) {
                        okayToProceed = false;
                    }
                });
            }
            return okayToProceed;
        }),

    // Are we ready to start playing the audio? Wait for recording (used if
    // doing a recording frame).
    readyToStartAudio: Ember.computed.and(&#x27;hasCamAccess&#x27;, &#x27;videoUploadConnected&#x27;),

    meta: {
        name: &#x27;ExpLookitDialoguePage&#x27;,
        description: &#x27;Frame to [TODO]&#x27;,
        parameters: {
            type: &#x27;object&#x27;,
            properties: {
                /**
                 * Phase number (just included as a convenience &amp; sent to server, to make handling collected data simpler)
                 *
                 * @property {Number} nPhase
                 * @default 0
                 */
                nPhase: {
                    type: &#x27;number&#x27;,
                    description: &#x27;Phase number&#x27;,
                    default: 0
                },
                /**
                 * Trial number (just included as a convenience &amp; sent to server, to make handling collected data simpler)
                 *
                 * @property {Number} nTrial
                 * @default 0
                 */
                nTrial: {
                    type: &#x27;number&#x27;,
                    description: &#x27;Trial number&#x27;,
                    default: 0
                },
                /**
                 * URL of background image; will be stretched to width of page
                 *
                 * @property {String} backgroundImage
                 */
                backgroundImage: {
                    type: &#x27;string&#x27;,
                    description: &#x27;URL of background image; will be stretched to width of page&#x27;
                },
                /**
                 * Whether this is a frame where the user needs to click to
                 * select one of the images before proceeding
                 *
                 * @property {Boolean} isChoiceFrame
                 * @default false
                 */
                isChoiceFrame: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether this is a frame where the user needs to click to select one of the images before proceeding&#x27;
                },
                /**
                 * Base directory for where to find stimuli. Any image src
                 * values that are not full paths will be expanded by prefixing
                 * with &#x60;baseDir&#x60; + &#x60;img/&#x60;. Any audio/video src values that give
                 * a value for &#x27;stub&#x27; rather than &#x27;src&#x27; and &#x27;type&#x27; will be
                 * expanded out to
                 * &#x60;baseDir/avtype/[stub].avtype&#x60;, where the potential avtypes
                 * are given by audioTypes and videoTypes.
                 *
                 * Note that baseDir SHOULD include a trailing slash
                 * (e.g., &#x60;http://stimuli.org/myexperiment/&#x60;, not
                 * &#x60;http://stimuli.org/myexperiment&#x60;)
                 *
                 * @property {String} baseDir
                 * @default &#x27;&#x27;
                 */
                baseDir: {
                    type: &#x27;string&#x27;,
                    default: &#x27;&#x27;,
                    description: &#x27;Base directory for all stimuli&#x27;
                },
                /**
                 * List of audio types to expect for any audio specified just
                 * with a string rather than with a list of src/type pairs.
                 * If audioTypes is [&#x27;typeA&#x27;, &#x27;typeB&#x27;] and an audio source
                 * is given as [{&#x27;stub&#x27;: &#x27;intro&#x27;}], the audio source will be
                 * expanded out to
                 *
&#x60;&#x60;&#x60;json
                 [
                        {
                            src: &#x27;baseDir&#x27; + &#x27;typeA/intro.typeA&#x27;,
                            type: &#x27;audio/typeA&#x27;
                        },
                        {
                            src: &#x27;baseDir&#x27; + &#x27;typeB/intro.typeB&#x27;,
                            type: &#x27;audio/typeB&#x27;
                        }
                ]
&#x60;&#x60;&#x60;
                 *
                 * @property {String[]} audioTypes
                 * @default [&#x27;mp3&#x27;, &#x27;ogg&#x27;]
                 */
                audioTypes: {
                    type: &#x27;array&#x27;,
                    default: [&#x27;mp3&#x27;, &#x27;ogg&#x27;],
                    description: &#x27;List of audio types to expect for any audio sources specified as strings rather than lists of src/type pairs&#x27;
                },
                /**
                 * Whether to do webcam recording (will wait for webcam
                 * connection before starting audio if so)
                 *
                 * @property {Boolean} doRecording
                 */
                doRecording: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether to do webcam recording (will wait for webcam connection before starting audio if so&#x27;
                },
                /**
                 * Whether to proceed automatically after audio (and hide
                 * replay/next buttons)
                 *
                 * @property {Boolean} autoProceed
                 */
                autoProceed: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether to proceed automatically after audio (and hide replay/next buttons)&#x27;
                },
                /**
                 * Array of objects describing audio to play at the start of
                 * this frame. Each element describes a separate audio segment.
                 *
                 * @property {Object[]} audioSources
                 *   @param {String} audioId unique string identifying this
                 *      audio segment
                 *   @param {Object[]} sources Array of {src: &#x27;url&#x27;, type:
                 *      &#x27;MIMEtype&#x27;} objects with audio sources for this segment.
                 *
                 * Can also give a single element {stub: &#x27;filename&#x27;}, which will
                 * be expanded out to the appropriate array based on &#x60;baseDir&#x60;
                 * and &#x60;audioTypes&#x60; values; see &#x60;audioTypes&#x60;.
                 *
                 *   @param {Object[]} highlights Array of {&#x27;range&#x27;: [startT,
                 *      endT], &#x27;image&#x27;: &#x27;imageId&#x27;} objects, where the imageId
                 *      values correspond to the ids given in images
                 */
                audioSources: {
                    type: &#x27;array&#x27;,
                    description: &#x27;List of objects specifying audio src and type for audio played during test trial&#x27;,
                    default: [],
                    items: {
                        type: &#x27;object&#x27;,
                        properties: {
                            &#x27;audioId&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;sources&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;src&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;type&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;stub&#x27;: {
                                            type: &#x27;string&#x27;
                                        }
                                    }
                                }
                            },
                            &#x27;highlights&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;range&#x27;: {
                                            type: &#x27;array&#x27;,
                                            items: {
                                                type: &#x27;number&#x27;
                                            }
                                        },
                                        &#x27;image&#x27;: {
                                            &#x27;type&#x27;: &#x27;string&#x27;
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                /**
                 * Text block to display to parent.
                 *
                 * @property {Object} parentTextBlock
                 *   @param {String} title title to display
                 *   @param {String} text paragraph of text
                 *   @param {Boolean} emph whether to bold this paragraph
                 */
                parentTextBlock: {
                    type: &#x27;object&#x27;,
                    properties: {
                        title: {
                            type: &#x27;string&#x27;
                        },
                        text: {
                            type: &#x27;string&#x27;
                        },
                        emph: {
                            type: &#x27;boolean&#x27;
                        }
                    },
                    default: []
                },
                /**
                 * Array of images to display and information about their placement
                 *
                 * @property {Object[]} images
                 *   @param {String} id unique ID for this image. This will be used to refer to the choice made by the user, if any.
                 *   @param {String} src URL of image source (can be full URL, or stub to append to baseDir; see &#x60;baseDir&#x60;)
                 *   @param {String} left left margin, as percentage of story area width
                 *   @param {String} height image height, as percentage of story area height
                 *   @param {String} bottom bottom margin, as percentage of story area height
                 *   @param {String} animate animation to use at start of trial on this image, if any. If not provided, image is shown throughout trial. Options are &#x27;fadein&#x27;, &#x27;fadeout&#x27;, &#x27;flyleft&#x27; (fly from left), and &#x27;flyright&#x27;.
                 *   @param {String} text text to display above image, e.g. &#x27;Click to hear what he said!&#x27; If omitted, no text is shown.
                 *   @param {Object[]} imageAudio sources Array of {src: &#x27;url&#x27;,
                 * type: &#x27;MIMEtype&#x27;} objects with audio sources for audio to play when this image is clicked, if any. (Omit to not associate audio with this image.)
                 *
                 * Can also give a single element {stub: &#x27;filename&#x27;}, which will
                 * be expanded out to the appropriate array based on &#x60;baseDir&#x60;
                 * and &#x60;audioTypes&#x60; values; see &#x60;audioTypes&#x60;.
                 *
                 *   @param {Boolean} requireAudio whether to require the user to click this image and complete the audio associated before proceeding to the next trial. (Incompatible with autoProceed.)
                 */
                images: {
                    type: &#x27;array&#x27;,
                    items: {
                        type: &#x27;object&#x27;,
                        properties: {
                            &#x27;id&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;src&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;left&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;height&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;bottom&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;animate&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;text&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;imageAudio&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;src&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;type&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;stub&#x27;: {
                                            type: &#x27;string&#x27;
                                        }
                                    }
                                }
                            },
                            &#x27;requireAudio&#x27;: {
                                type: &#x27;boolean&#x27;
                            }
                        }
                    }
                }
            }
        },
        data: {
            /**
             * Parameters captured and sent to the server
             *
             * @method serializeContent
             * @param {String} videoID The ID of any video recorded during this frame
             * @param {Object} eventTimings
             * @param {String} currentlyHighlighted which image is selected at
             *   the end of the trial, or null if none is. This indicates the
             *   final selected choice for a choice trial.
             * @return {Object} The payload sent to the server
             */
            type: &#x27;object&#x27;,
            properties: {
                videoId: {
                    type: &#x27;string&#x27;
                },
                currentlyHighlighted: {
                    type: &#x27;string&#x27;
                },
                nTrial: {
                    type: &#x27;number&#x27;
                },
                nPhase: {
                    type: &#x27;number&#x27;
                }
            }
        }
    },

    audioObserver: Ember.observer(&#x27;readyToStartAudio&#x27;, function(frame) {
        if (frame.get(&#x27;readyToStartAudio&#x27;)) {
            frame.set(&#x27;currentAudioIndex&#x27;, -1);
            frame.send(&#x27;playNextAudioSegment&#x27;);
        }
    }),

    actions: {

        clickSpeaker(imageId) {
            // On a choice frame, highlight this choice
            if (this.get(&#x27;isChoiceFrame&#x27;)) {

                /**
                 * When one of the images is clicked during a choice frame
                 *
                 * @event clickSpeaker
                 * @param {String} imageId
                 */
                this.sendTimeEvent(&#x27;clickSpeaker&#x27;, {
                    imageId: imageId
                });

                $(&#x27;.story-image-container&#x27;).removeClass(&#x27;highlight&#x27;);
                $(&#x27;#&#x27; + imageId).addClass(&#x27;highlight&#x27;);
                this.set(&#x27;currentlyHighlighted&#x27;, imageId);
                this.notifyPropertyChange(&#x27;readyToProceed&#x27;);

            // In general, play audio associated with this image
            } else {
                // Only allow playing image audio once main narration finishes
                if (this.get(&#x27;completedAudio&#x27;)) {
                    // pause any current audio, and set times to 0
                    $(&#x27;audio&#x27;).each(function() {
                        this.pause();
                        this.currentTime = 0;
                    });
                    // play this image&#x27;s associated audio
                    $(&#x27;#&#x27; + imageId + &#x27; audio&#x27;)[0].play();

                    /**
                     * When image audio is started
                     *
                     * @event startSpeakerAudio
                     * @param {String} imageId
                     */
                    this.sendTimeEvent(&#x27;startSpeakerAudio&#x27;, {
                        imageId: imageId
                    });
                }
            }
        },

        markAudioCompleted(imageId) {

            /**
             * When image audio is completed (not recorded if interrupted)
             *
             * @event completeSpeakerAudio
             * @param {String} imageId
             */
            this.sendTimeEvent(&#x27;completeSpeakerAudio&#x27;, {
                imageId: imageId
            });

            this.imageAudioCompleted.add(imageId);
            this.notifyPropertyChange(&#x27;readyToProceed&#x27;);
        },

        replay() {
            // pause any current audio, and set times to 0
            $(&#x27;audio&#x27;).each(function() {
                this.pause();
                this.currentTime = 0;
            });
            // reset to index -1 as at start of study
            this.set(&#x27;currentAudioIndex&#x27;, -1);
            // restart audio
            this.send(&#x27;playNextAudioSegment&#x27;);
        },

        next() {
            if (this.get(&#x27;recorder&#x27;)) {
                /**
                 * Just before stopping webcam video capture
                 *
                 * @event stoppingCapture
                 */
                this.sendTimeEvent(&#x27;stoppingCapture&#x27;);
                this.get(&#x27;recorder&#x27;).stop();
            }
            this._super(...arguments);
        },

        playNextAudioSegment() {
            this.set(&#x27;currentAudioIndex&#x27;, this.get(&#x27;currentAudioIndex&#x27;) + 1);
            if (this.currentAudioIndex &lt; this.get(&#x27;audioSources&#x27;).length) {
                $(&#x27;#&#x27; + this.get(&#x27;audioSources&#x27;)[this.currentAudioIndex].audioId)[0].play();
            } else {
                if (this.get(&#x27;autoProceed&#x27;)) {
                    this.send(&#x27;next&#x27;);
                } else {
                    /**
                     * When narration audio is completed
                     *
                     * @event completeMainAudio
                     */
                    this.sendTimeEvent(&#x27;completeMainAudio&#x27;);
                    this.set(&#x27;completedAudio&#x27;, true);
                    this.notifyPropertyChange(&#x27;readyToProceed&#x27;);
                }
            }
        }

    },

    // Utility to expand stubs into either full URLs (for images) or
    // array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects (for audio).
    expandAsset(asset, type) {
        var fullAsset = asset;
        var _this = this;

        if (type === &#x27;image&#x27; &amp;&amp; typeof asset === &#x27;string&#x27; &amp;&amp; !(asset.includes(&#x27;://&#x27;))) {
            // Image: replace stub with full URL if needed
            fullAsset = this.get(&#x27;baseDir&#x27;) + &#x27;img/&#x27; + asset;
        } else if (type === &#x27;audio&#x27;) {
            // Audio: replace any source objects that have a
            // &#x27;stub&#x27; attribute with the appropriate expanded source
            // objects
            fullAsset = [];
            var types = this.get(&#x27;audioTypes&#x27;);
            asset.forEach(function(srcObj) {
                if (srcObj.hasOwnProperty(&#x27;stub&#x27;)) {
                    for (var iType = 0; iType &lt; types.length; iType++) {
                        fullAsset.push({
                            src: _this.get(&#x27;baseDir&#x27;) + types[iType] + &#x27;/&#x27; + srcObj.stub + &#x27;.&#x27; + types[iType],
                            type: type + &#x27;/&#x27; + types[iType]
                        });
                    }
                } else {
                    fullAsset.push(srcObj);
                }
            });
        }
        return fullAsset;
    },

    // TODO: should this be moved to the recording mixin?
    sendTimeEvent(name, opts = {}) {
        var streamTime = this.get(&#x27;recorder&#x27;) ? this.get(&#x27;recorder&#x27;).getTime() : null;
        Ember.merge(opts, {
            streamTime: streamTime,
            videoId: this.get(&#x27;videoId&#x27;)
        });
        this.send(&#x27;setTimeEvent&#x27;, &#x60;exp-lookit-dialogue-page:${name}&#x60;, opts);
    },

    // TODO: should the events here be moved to the fullscreen mixin?
    onFullscreen() {
        if (this.get(&#x27;isDestroyed&#x27;)) {
            return;
        }
        this._super(...arguments);
        if (!this.checkFullscreen()) {
            /**
             * Upon detecting change out of fullscreen mode
             *
             * @event leftFullscreen
            */
            this.sendTimeEvent(&#x27;leftFullscreen&#x27;);
        } else {
            /**
             * Upon detecting change to fullscreen mode
             *
             * @event enteredFullscreen
            */
            this.sendTimeEvent(&#x27;enteredFullscreen&#x27;);
        }
    },

    didInsertElement() {
        this._super(...arguments);

        // Expand any image src stubs &amp; imageAudio stubs
        var _this = this;
        var images = this.get(&#x27;images&#x27;);
        images.forEach(function(im) {
            Ember.set(im, &#x27;src_parsed&#x27;, _this.expandAsset(im.src, &#x27;image&#x27;));
            if (im.hasOwnProperty(&#x27;imageAudio&#x27;)) {
                Ember.set(im, &#x27;imageAudio_parsed&#x27;, _this.expandAsset(im.imageAudio, &#x27;audio&#x27;));
            }
        });
        this.set(&#x27;backgroundImage_parsed&#x27;, _this.expandAsset(this.backgroundImage, &#x27;image&#x27;));

        // Expand any audio src stubs
        var audioSources = this.get(&#x27;audioSources&#x27;);
        audioSources.forEach(function(aud) {
            Ember.set(aud, &#x27;sources_parsed&#x27;, _this.expandAsset(aud.sources, &#x27;audio&#x27;));
        });

        this.set(&#x27;images&#x27;, images);
        this.set(&#x27;audioSources&#x27;, audioSources);

        this.send(&#x27;showFullscreen&#x27;);
        $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, true);

        // Any animations as images are displayed at start of this phase
        $(&#x27;.story-image-container&#x27;).hide();
        this.get(&#x27;images&#x27;).forEach(function (im) {
            if (im.animate === &#x27;fadein&#x27;) {
                $(&#x27;#&#x27; + im.id).fadeIn(1000);
            } if (im.animate === &#x27;fadeout&#x27;) {
                $(&#x27;#&#x27; + im.id).show();
                $(&#x27;#&#x27; + im.id).fadeOut(1000);
            }else if (im.animate === &#x27;flyleft&#x27;) {
                $(&#x27;#&#x27; + im.id).show();
                $(&#x27;#&#x27; + im.id).css(&#x27;left&#x27;, &#x27;-20%&#x27;);
                $(&#x27;#&#x27; + im.id).animate({
                    left: im.left + &#x27;%&#x27;
                }, 1500);
            } else if (im.animate === &#x27;flyright&#x27;) {
                $(&#x27;#&#x27; + im.id).show();
                $(&#x27;#&#x27; + im.id).css(&#x27;left&#x27;, &#x27;100%&#x27;);
                $(&#x27;#&#x27; + im.id).animate({
                    left: im.left + &#x27;%&#x27;
                }, 1500);
            }else {
                $(&#x27;#&#x27; + im.id).show();
            }
        });

        // If we&#x27;re recording this trial, set up, and rely on audioObserver to
        // start audio once recording is ready. Otherwise, start audio right
        // away.
        if (_this.get(&#x27;doRecording&#x27;)) {
            if (_this.get(&#x27;experiment&#x27;) &amp;&amp; _this.get(&#x27;id&#x27;) &amp;&amp; _this.get(&#x27;session&#x27;)) {
                let recorder = _this.get(&#x27;videoRecorder&#x27;).start(_this.get(&#x27;videoId&#x27;), _this.$(&#x27;#videoRecorder&#x27;), {
                    hidden: true
                });
                recorder.install({
                    record: true
                }).then(() =&gt; {
                    _this.sendTimeEvent(&#x27;recorderReady&#x27;);
                    _this.set(&#x27;recordingIsReady&#x27;, true);
                    _this.notifyPropertyChange(&#x27;readyToStartAudio&#x27;);
                });
                // TODO: move handlers that just record events to the VideoRecord mixin?
                /**
                 * When recorder detects a change in camera access
                 *
                 * @event onCamAccess
                 * @param {Boolean} hasCamAccess
                 */
                recorder.on(&#x27;onCamAccess&#x27;, (hasAccess) =&gt; {
                    _this.sendTimeEvent(&#x27;hasCamAccess&#x27;, {
                        hasCamAccess: hasAccess
                    });
                    _this.notifyPropertyChange(&#x27;readyToStartAudio&#x27;);
                });
                /**
                 * When recorder detects a change in video stream connection status
                 *
                 * @event videoStreamConnection
                 * @param {String} status status of video stream connection, e.g.
                 * &#x27;NetConnection.Connect.Success&#x27; if successful
                 */
                recorder.on(&#x27;onConnectionStatus&#x27;, (status) =&gt; {
                    _this.sendTimeEvent(&#x27;videoStreamConnection&#x27;, {
                        status: status
                    });
                    _this.notifyPropertyChange(&#x27;readyToStartAudio&#x27;);
                });
                _this.set(&#x27;recorder&#x27;, recorder);
            }
        } else {
            _this.send(&#x27;playNextAudioSegment&#x27;);
        }

    },

    willDestroyElement() {
        this.sendTimeEvent(&#x27;destroyingElement&#x27;);

        // Whenever the component is destroyed, make sure that event handlers are removed and video recorder is stopped
        if (this.get(&#x27;recorder&#x27;)) {
            this.get(&#x27;recorder&#x27;).hide(); // Hide the webcam config screen
            this.get(&#x27;recorder&#x27;).stop();
        }

        this._super(...arguments);
    }

});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
