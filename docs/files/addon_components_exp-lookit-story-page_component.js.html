<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/components/exp-lookit-story-page/component.js - exp-player</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="exp-player" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ExpExitSurvey.html">ExpExitSurvey</a></li>
                                <li><a href="../classes/ExpExitSurveyPilot.html">ExpExitSurveyPilot</a></li>
                                <li><a href="../classes/ExpFrameBase.html">ExpFrameBase</a></li>
                                <li><a href="../classes/ExpFrameBaseUnsafe.html">ExpFrameBaseUnsafe</a></li>
                                <li><a href="../classes/ExpLookitDialoguePage.html">ExpLookitDialoguePage</a></li>
                                <li><a href="../classes/ExpLookitExitSurvey.html">ExpLookitExitSurvey</a></li>
                                <li><a href="../classes/ExpLookitGeometryAlternation.html">ExpLookitGeometryAlternation</a></li>
                                <li><a href="../classes/ExpLookitInstructions.html">ExpLookitInstructions</a></li>
                                <li><a href="../classes/ExpLookitMoodQuestionnaire.html">ExpLookitMoodQuestionnaire</a></li>
                                <li><a href="../classes/ExpLookitPreferentialLooking.html">ExpLookitPreferentialLooking</a></li>
                                <li><a href="../classes/ExpLookitPreviewExplanation.html">ExpLookitPreviewExplanation</a></li>
                                <li><a href="../classes/ExpLookitStoryPage.html">ExpLookitStoryPage</a></li>
                                <li><a href="../classes/ExpLookitText.html">ExpLookitText</a></li>
                                <li><a href="../classes/ExpMoodQuestionnaire.html">ExpMoodQuestionnaire</a></li>
                                <li><a href="../classes/ExpPhysicsIntro.html">ExpPhysicsIntro</a></li>
                                <li><a href="../classes/ExpPhysicsPreVideo.html">ExpPhysicsPreVideo</a></li>
                                <li><a href="../classes/ExpPhysicsPreviewExplanation.html">ExpPhysicsPreviewExplanation</a></li>
                                <li><a href="../classes/ExpPlayer.html">ExpPlayer</a></li>
                                <li><a href="../classes/ExpVideoConfig.html">ExpVideoConfig</a></li>
                                <li><a href="../classes/ExpVideoConfigQuality.html">ExpVideoConfigQuality</a></li>
                                <li><a href="../classes/ExpVideoConsent.html">ExpVideoConsent</a></li>
                                <li><a href="../classes/ExpVideoPhysics.html">ExpVideoPhysics</a></li>
                                <li><a href="../classes/ExpVideoPreview.html">ExpVideoPreview</a></li>
                                <li><a href="../classes/FullScreen.html">FullScreen</a></li>
                                <li><a href="../classes/geometry.html">geometry</a></li>
                                <li><a href="../classes/MediaReload.html">MediaReload</a></li>
                                <li><a href="../classes/randomParameterSet.html">randomParameterSet</a></li>
                                <li><a href="../classes/videoRecorder.html">videoRecorder</a></li>
                                <li><a href="../classes/VideoRecorderObject.html">VideoRecorderObject</a></li>
                                <li><a href="../classes/VideoRecordMixin.html">VideoRecordMixin</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/components.html">components</a></li>
                                <li><a href="../modules/exp-player.html">exp-player</a></li>
                                <li><a href="../modules/frames.html">frames</a></li>
                                <li><a href="../modules/mixins.html">mixins</a></li>
                                <li><a href="../modules/randomizers.html">randomizers</a></li>
                                <li><a href="../modules/services.html">services</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: addon/components/exp-lookit-story-page/component.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import layout from &#x27;./template&#x27;;
import ExpFrameBaseUnsafeComponent from &#x27;../../components/exp-frame-base-unsafe/component&#x27;;
import FullScreen from &#x27;../../mixins/full-screen&#x27;;
import VideoRecord from &#x27;../../mixins/video-record&#x27;;

let {
    $
} = Ember;

/**
 * @module exp-player
 * @submodule frames
 */

/**
 * Frame to implement a basic &quot;storybook page&quot; trial, with images placed on the
 * screen within a display area and a sequence of audio files played.
 * Optionally, images may be highlighted at specified times during the audio
 * files.
 *
 * Webcam recording may be turned on or off; if on, the page is not displayed
 * or audio started until recording begins.
 *
 * Frame is displayed fullscreen, but is not paused or otherwise disabled if the
 * user leaves fullscreen. A button appears prompting the user to return to
 * fullscreen mode.
 *
 * The parent may press &#x27;next&#x27; to proceed, or the study may proceed
 * automatically when audio finishes (autoProceed).
 *
 * Any number of images may be placed on the screen, and their position
 * specified. (Aspect ratio will be the same as the original image.)
 *
 * These frames extend ExpFrameBaseUnsafe because they are displayed fullscreen
 * and expected to be repeated.

&#x60;&#x60;&#x60;json
 &quot;frames&quot;: {
    &quot;story-intro-1&quot;: {
            &quot;doRecording&quot;: false,
            &quot;autoProceed&quot;: true,
            &quot;baseDir&quot;: &quot;https://s3.amazonaws.com/lookitcontents/ingroupobligations/&quot;,
            &quot;audioTypes&quot;: [&quot;mp3&quot;, &quot;ogg&quot;],
            &quot;parentTextBlock&quot;: {
                &quot;title&quot;: &quot;Parents!&quot;,
                &quot;text&quot;: &quot;some instructions&quot;,
                &quot;emph&quot;: true
            },
            &quot;images&quot;: [
                {
                    &quot;id&quot;: &quot;leftA&quot;,
                    &quot;src&quot;: &quot;flurps1.jpg&quot;,
                    &quot;left&quot;: &quot;10&quot;,
                    &quot;width&quot;: &quot;30&quot;,
                    &quot;top&quot;: &quot;34.47&quot;
                },
                {
                    &quot;id&quot;: &quot;rightA&quot;,
                    &quot;src&quot;: &quot;zazzes1.jpg&quot;,
                    &quot;left&quot;: &quot;60&quot;,
                    &quot;width&quot;: &quot;30&quot;,
                    &quot;top&quot;: &quot;34.47&quot;
                }
            ],
            &quot;kind&quot;: &quot;exp-lookit-story-page&quot;,
            &quot;id&quot;: &quot;story-intro-1&quot;,
            &quot;audioSources&quot;: [
                {
                    &quot;audioId&quot;: &quot;firstAudio&quot;,
                    &quot;sources&quot;: [
                        {
                            &quot;stub&quot;: &quot;intro1&quot;
                        }
                    ],
                    &quot;highlights&quot;: [
                        {&quot;range&quot;: [3.017343,	5.600283], &quot;image&quot;: 	&quot;leftA&quot;},
                        {&quot;range&quot;: [5.752911,	8.899402], &quot;image&quot;: 	&quot;rightA&quot;}
                    ]
                }
            ]
        }
 }

 * &#x60;&#x60;&#x60;
 * @class ExpLookitStoryPage
 * @extends ExpFrameBaseUnsafe
 * @uses FullScreen
 * @uses VideoRecord
 */

export default ExpFrameBaseUnsafeComponent.extend(FullScreen, VideoRecord,  {
    // In the Lookit use case, the frame BEFORE the one that goes fullscreen
    // must use &quot;unsafe&quot; saves (in order for the fullscreen event to register as
    // being user-initiated and not from a promise handler) #LEI-369.
    // exp-alternation frames are expected to be repeated, so they need to be
    // unsafe.
    type: &#x27;exp-lookit-story-page&#x27;,
    layout: layout,
    displayFullscreen: true, // force fullscreen for all uses of this component
    fullScreenElementId: &#x27;experiment-player&#x27;,
    fsButtonID: &#x27;fsButton&#x27;,
    videoRecorder: Ember.inject.service(),
    recorder: null,
    hasCamAccess: Ember.computed.alias(&#x27;recorder.hasCamAccess&#x27;),
    videoUploadConnected: Ember.computed.alias(&#x27;recorder.connected&#x27;),

    // Track state of experiment
    completedAudio: false,
    completedAttn: false,
    currentSegment: &#x27;intro&#x27;, // &#x27;calibration&#x27;, &#x27;test&#x27;, &#x27;finalaudio&#x27; (mutually exclusive)
    previousSegment: &#x27;intro&#x27;, // used when pausing/unpausing - refers to segment that study was paused during

    currentAudioIndex: -1, // during initial sequential audio, holds an index into audioSources

    readyToStartAudio: Ember.computed(&#x27;hasCamAccess&#x27;, &#x27;videoUploadConnected&#x27;,
        function() {
            return (this.get(&#x27;hasCamAccess&#x27;) &amp;&amp; this.get(&#x27;videoUploadConnected&#x27;));
        }),

    meta: {
        name: &#x27;ExpLookitStoryPage&#x27;,
        description: &#x27;Frame to [TODO]&#x27;,
        parameters: {
            type: &#x27;object&#x27;,
            properties: {
                /**
                 * Whether to do webcam recording (will wait for webcam
                 * connection before starting audio if so)
                 *
                 * @property {Boolean} doRecording
                 */
                doRecording: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether to do webcam recording (will wait for webcam connection before starting audio if so&#x27;
                },
                /**
                 * Whether to proceed automatically after audio (and hide
                 * replay/next buttons)
                 *
                 * @property {Boolean} autoProceed
                 */
                autoProceed: {
                    type: &#x27;boolean&#x27;,
                    description: &#x27;Whether to proceed automatically after audio (and hide replay/next buttons)&#x27;
                },
                /**
                 * Base directory for where to find stimuli. Any image src
                 * values that are not full paths will be expanded by prefixing
                 * with &#x60;baseDir&#x60; + &#x60;img/&#x60;. Any audio/video src values that give
                 * a value for &#x27;stub&#x27; rather than &#x27;src&#x27; and &#x27;type&#x27; will be
                 * expanded out to
                 * &#x60;baseDir/avtype/[stub].avtype&#x60;, where the potential avtypes
                 * are given by audioTypes and videoTypes.
                 *
                 * Note that baseDir SHOULD include a trailing slash
                 * (e.g., &#x60;http://stimuli.org/myexperiment/&#x60;, not
                 * &#x60;http://stimuli.org/myexperiment&#x60;)
                 *
                 * @property {String} baseDir
                 * @default &#x27;&#x27;
                 */
                baseDir: {
                    type: &#x27;string&#x27;,
                    default: &#x27;&#x27;,
                    description: &#x27;Base directory for all stimuli&#x27;
                },
                /**
                 * List of audio types to expect for any audio specified just
                 * with a string rather than with a list of src/type pairs.
                 * If audioTypes is [&#x27;typeA&#x27;, &#x27;typeB&#x27;] and an audio source
                 * is given as [{&#x27;stub&#x27;: &#x27;intro&#x27;}], the audio source will be
                 * expanded out to
                 *
&#x60;&#x60;&#x60;json
                 [
                        {
                            src: &#x27;baseDir&#x27; + &#x27;typeA/intro.typeA&#x27;,
                            type: &#x27;audio/typeA&#x27;
                        },
                        {
                            src: &#x27;baseDir&#x27; + &#x27;typeB/intro.typeB&#x27;,
                            type: &#x27;audio/typeB&#x27;
                        }
                ]
&#x60;&#x60;&#x60;
                 *
                 * @property {String[]} audioTypes
                 * @default [&#x27;mp3&#x27;, &#x27;ogg&#x27;]
                 */
                audioTypes: {
                    type: &#x27;array&#x27;,
                    default: [&#x27;mp3&#x27;, &#x27;ogg&#x27;],
                    description: &#x27;List of audio types to expect for any audio sources specified as strings rather than lists of src/type pairs&#x27;
                },
                /**
                 * Array of objects describing audio to play at the start of
                 * this frame. Each element describes a separate audio segment.
                 *
                 * @property {Object[]} audioSources
                 *   @param {String} audioId unique string identifying this
                 *      audio segment
                 *   @param {Object[]} sources Array of {src: &#x27;url&#x27;, type:
                 *      &#x27;MIMEtype&#x27;} objects with audio sources for this segment
                 *
                 * Can also give a single element {stub: &#x27;filename&#x27;}, which will
                 * be expanded out to the appropriate array based on &#x60;baseDir&#x60;
                 * and &#x60;audioTypes&#x60; values; see &#x60;audioTypes&#x60;.
                 *
                 *   @param {Object[]} highlights Array of {&#x27;range&#x27;: [startT,
                 *      endT], &#x27;image&#x27;: &#x27;imageId&#x27;} objects, where the imageId
                 *      values correspond to the ids given in images
                 */
                audioSources: {
                    type: &#x27;array&#x27;,
                    description: &#x27;List of objects specifying audio src and type for audio played during test trial&#x27;,
                    default: [],
                    items: {
                        type: &#x27;object&#x27;,
                        properties: {
                            &#x27;audioId&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;sources&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;src&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;type&#x27;: {
                                            type: &#x27;string&#x27;
                                        },
                                        &#x27;stub&#x27;: {
                                            type: &#x27;string&#x27;
                                        }
                                    }
                                }
                            },
                            &#x27;highlights&#x27;: {
                                type: &#x27;array&#x27;,
                                items: {
                                    type: &#x27;object&#x27;,
                                    properties: {
                                        &#x27;range&#x27;: {
                                            type: &#x27;array&#x27;,
                                            items: {
                                                type: &#x27;number&#x27;
                                            }
                                        },
                                        &#x27;image&#x27;: {
                                            &#x27;type&#x27;: &#x27;string&#x27;
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                /**
                 * Text block to display to parent.
                 *
                 * @property {Object} parentTextBlock
                 *   @param {String} title title to display
                 *   @param {String} text paragraph of text
                 *   @param {Boolean} emph whether to bold this paragraph
                 */
                parentTextBlock: {
                    type: &#x27;object&#x27;,
                    properties: {
                        title: {
                            type: &#x27;string&#x27;
                        },
                        text: {
                            type: &#x27;string&#x27;
                        },
                        emph: {
                            type: &#x27;boolean&#x27;
                        }
                    },
                    default: []
                },
                /**
                 * Array of images to display and information about their placement
                 *
                 * @property {Object[]} images
                 *   @param {String} id unique ID for this image
                 *   @param {String} src URL of image source. This can be a full
                 *     URL, or relative to baseDir (see baseDir).
                 *   @param {String} left left margin, as percentage of story area width
                 *   @param {String} width image width, as percentage of story area width
                 *   @param {String} top top margin, as percentage of story area height

                 */
                images: {
                    type: &#x27;array&#x27;,
                    items: {
                        type: &#x27;object&#x27;,
                        properties: {
                            &#x27;id&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;src&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;left&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;width&#x27;: {
                                type: &#x27;string&#x27;
                            },
                            &#x27;top&#x27;: {
                                type: &#x27;string&#x27;
                            }
                        }
                    }
                }
            }
        },
        data: {
            /**
             * Parameters captured and sent to the server
             *
             * @method serializeContent
             * @param {String} videoID The ID of any video recorded during this frame
             * @param {Object} eventTimings
             * @return {Object} The payload sent to the server
             */
            type: &#x27;object&#x27;,
            properties: {
                videoId: {
                    type: &#x27;string&#x27;
                }
            }
        }
    },

    audioObserver: Ember.observer(&#x27;readyToStartAudio&#x27;, function(frame) {
        if (frame.get(&#x27;readyToStartAudio&#x27;)) {
            $(&#x27;#waitForVideo&#x27;).hide();
            $(&#x27;.story-image-container&#x27;).show();
            frame.set(&#x27;currentAudioIndex&#x27;, -1);
            frame.send(&#x27;playNextAudioSegment&#x27;);
        }
    }),

    actions: {

        // During playing audio
        updateCharacterHighlighting() {

            var thisAudioData = this.get(&#x27;audioSources&#x27;)[this.currentAudioIndex];
            var t = $(&#x27;#&#x27; + thisAudioData.audioId)[0].currentTime;

            $(&#x27;.story-image-container&#x27;).removeClass(&#x27;highlight&#x27;);

            thisAudioData.highlights.forEach(function (h) {
                if (t &gt; h.range[0] &amp;&amp; t &lt; h.range[1]) {
                    $(&#x27;#&#x27; + h.image).addClass(&#x27;highlight&#x27;);
                }
            });
        },

        replay() {
            // pause any current audio, and set times to 0
            $(&#x27;audio&#x27;).each(function() {
                this.pause();
                this.currentTime = 0;
            });
            // reset to index -1 as at start of study
            this.set(&#x27;currentAudioIndex&#x27;, -1);
            // restart audio
            this.send(&#x27;playNextAudioSegment&#x27;);
        },

        next() {
            /**
             * Just before stopping webcam video capture
             *
             * @event stoppingCapture
             */
            this.stopRecorder();
            this._super(...arguments);
        },

        playNextAudioSegment() {
            this.set(&#x27;currentAudioIndex&#x27;, this.get(&#x27;currentAudioIndex&#x27;) + 1);
            if (this.currentAudioIndex &lt; this.get(&#x27;audioSources&#x27;).length) {
                $(&#x27;#&#x27; + this.get(&#x27;audioSources&#x27;)[this.currentAudioIndex].audioId)[0].play();
            } else {
                if (this.get(&#x27;autoProceed&#x27;)) {
                    this.send(&#x27;next&#x27;);
                } else {
                    $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, false);
                }
            }
        }

    },

    // Utility to expand stubs into either full URLs (for images) or
    // array of {src: &#x27;url&#x27;, type: &#x27;MIMEtype&#x27;} objects (for audio).
    expandAsset(asset, type) {
        var fullAsset = asset;
        var _this = this;

        if (type === &#x27;image&#x27; &amp;&amp; typeof asset === &#x27;string&#x27; &amp;&amp; !(asset.includes(&#x27;://&#x27;))) {
            // Image: replace stub with full URL if needed
            fullAsset = this.baseDir + &#x27;img/&#x27; + asset;
        } else if (type === &#x27;audio&#x27;) {
            // Audio: replace any source objects that have a
            // &#x27;stub&#x27; attribute with the appropriate expanded source
            // objects
            fullAsset = [];
            var types = this.audioTypes;
            asset.forEach(function(srcObj) {
                if (srcObj.hasOwnProperty(&#x27;stub&#x27;)) {
                    for (var iType = 0; iType &lt; types.length; iType++) {
                        fullAsset.push({
                            src: _this.baseDir + types[iType] + &#x27;/&#x27; + srcObj.stub + &#x27;.&#x27; + types[iType],
                            type: type + &#x27;/&#x27; + types[iType]
                        });
                    }
                } else {
                    fullAsset.push(srcObj);
                }
            });
        }
        return fullAsset;
    },

    makeTimeEvent(eventName, extra) {
        return this._super(&#x60;exp-lookit-story-page:${eventName}&#x60;, extra);
    },

    // TODO: should the events here be moved to the fullscreen mixin?
    onFullscreen() {
        if (this.get(&#x27;isDestroyed&#x27;)) {
            return;
        }
        this._super(...arguments);
        if (!this.checkFullscreen()) {
            /**
             * Upon detecting change out of fullscreen mode
             *
             * @event leftFullscreen
            */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;leftFullscreen&#x27;);
        } else {
            /**
             * Upon detecting change to fullscreen mode
             *
             * @event enteredFullscreen
            */
            this.send(&#x27;setTimeEvent&#x27;, &#x27;enteredFullscreen&#x27;);
        }
    },

    didInsertElement() {
        this._super(...arguments);

        // Expand any image src stubs
        var images = this.get(&#x27;images&#x27;);
        images.forEach((im) =&gt; {
            Ember.set(im, &#x27;src&#x27;, this.expandAsset(im.src, &#x27;image&#x27;));
        });
        this.set(&#x27;images_parsed&#x27;, images);

        // Expand any audio src stubs
        var audioSources = this.get(&#x27;audioSources&#x27;);
        audioSources.forEach((aud) =&gt; {
            Ember.set(aud, &#x27;sources_parsed&#x27;, this.expandAsset(aud.sources, &#x27;audio&#x27;));
        });
        this.set(&#x27;audioSources&#x27;, audioSources);

        this.send(&#x27;showFullscreen&#x27;);
        $(&#x27;#nextbutton&#x27;).prop(&#x27;disabled&#x27;, true);

        if (this.get(&#x27;doRecording&#x27;)) {
            $(&#x27;.story-image-container&#x27;).hide();
            if (this.get(&#x27;experiment&#x27;) &amp;&amp; this.get(&#x27;id&#x27;) &amp;&amp; this.get(&#x27;session&#x27;)) {
                const installPromise = this.setupRecorder(this.$(&#x27;#videoRecorder&#x27;), true, {
                    hidden: true
                });
                installPromise.then(() =&gt; {
                    this.send(&#x27;setTimeEvent&#x27;, &#x27;recorderReady&#x27;);
                    this.set(&#x27;recordingIsReady&#x27;, true);
                    this.notifyPropertyChange(&#x27;readyToStartAudio&#x27;);
                });

                // TODO: move handlers that just record events to the VideoRecord mixin?
                /**
                 * When recorder detects a change in camera access
                 *
                 * @event onCamAccess
                 * @param {Boolean} hasCamAccess
                 */
                // Add event handler on top of what the VideoRecordMixin normally does
                const recorder = this.get(&#x27;recorder&#x27;);
                recorder.on(&#x27;onCamAccess&#x27;, () =&gt; {
                    this.notifyPropertyChange(&#x27;readyToStartAudio&#x27;);
                });
                /**
                 * When recorder detects a change in video stream connection status
                 *
                 * @event videoStreamConnection
                 * @param {String} status status of video stream connection, e.g.
                 * &#x27;NetConnection.Connect.Success&#x27; if successful
                 */
                recorder.on(&#x27;onConnectionStatus&#x27;, () =&gt; {
                    this.notifyPropertyChange(&#x27;readyToStartAudio&#x27;);
                });
            }
        } else {
            this.send(&#x27;playNextAudioSegment&#x27;);
        }

    },

    willDestroyElement() {
        this.send(&#x27;setTimeEvent&#x27;, &#x27;destroyingElement&#x27;);

        // Whenever the component is destroyed, make sure that event handlers are removed and video recorder is stopped
        const recorder = this.get(&#x27;recorder&#x27;);
        if (recorder) {
            recorder.hide(); // Hide the webcam config screen
            this.stopRecorder();
        }

        this._super(...arguments);
    }

});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
